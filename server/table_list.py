import json
from pathlib import Path
from typing import Dict, List

import cbsodata
import faiss
import numpy as np

from server.constants import (DEFAULT_TABLE_LIST_TOP_N, EMBED_BATCH_SIZE,
                              EMBEDDINGS, TABLE_LIST)
from server.pandas_custom_display import pd
from services.openai import get_embeddings


class CBSTableEmbedder:
    """
    Prepare CBS table metadata and generate embeddings for them.

    This class retrieves the table list from CBSodata, filters out discontinued tables,
    and saves the table list to a CSV file. It also generates embeddings for the table
    metadata using OpenAI's API and saves the embeddings to a JSON file.
    """

    def __init__(self):
        self._df = (
            self._get_table_list()
        )  # A DataFrame containing the metadata of CBS tables.
        self._embed_df = (
            self._get_table_embeddings()
        )  # A DataFrame containing the embeddings of the table metadata.
        self._joined_df = self._df.merge(self._embed_df, on="Identifier")

    @property
    def tables_with_embeddings_df(self) -> pd.DataFrame:
        return (
            self._joined_df
        )  # A DataFrame containing the metadata of CBS tables and their embeddings

    def _get_table_list(self) -> pd.DataFrame:
        table_list_path = Path(TABLE_LIST)

        if table_list_path.exists():
            df = pd.read_csv(table_list_path)
        else:
            tables = cbsodata.get_table_list()
            df = pd.DataFrame(tables)
            df = df[df.ReasonDelivery != "Stopgezet"]
            self._save_table_list(df)

        return df

    @staticmethod
    def _save_table_list(df: pd.DataFrame):
        df.to_csv(TABLE_LIST, index=False)

    def _get_table_embeddings(self) -> pd.DataFrame:
        embeddings_path = Path(EMBEDDINGS)

        if not embeddings_path.exists():
            self._embed_table_metadata_for_search()

        return pd.read_json(EMBEDDINGS, lines=True)

    def _embed_table_metadata_for_search(self):
        embeddings = []
        texts = []
        identifiers = []

        for idx, row in self.df.iterrows():
            identifier = row.Identifier
            text = " ".join(
                [row.Identifier, row.Summary, row.ShortDescription]
            ).replace("\n", " ")
            texts.append(text)
            identifiers.append(identifier)

            if len(texts) == EMBED_BATCH_SIZE:
                embeddings.extend(get_embeddings(texts))
                texts.clear()

        if texts:
            embeddings.extend(get_embeddings(texts))

        self._save_embeddings_to_file(identifiers, embeddings)

    @staticmethod
    def _save_embeddings_to_file(identifiers: List[str], embeddings: List[np.ndarray]):
        with open(EMBEDDINGS, "w") as file:
            for identifier, embedding in zip(identifiers, embeddings):
                embedding_data = {"Identifier": identifier, "Embedding": embedding}
                file.write(json.dumps(embedding_data) + "\n")


class CBSTableSearcher:
    """
    Search for CBS tables using their metadata embeddings.

    This class initializes a FAISS index using the embeddings generated by the
    CBSTableEmbedder class. It provides a method to search for similar tables
    using a text query.
    """

    def __init__(self, embedder: CBSTableEmbedder):
        self._tables_with_embeddings_df = embedder.tables_with_embeddings_df
        self.embeddings = np.vstack(self._tables_with_embeddings_df.Embedding.to_list())
        self.index = self._build_faiss_index(self.embeddings)

    @staticmethod
    def _build_faiss_index(embeddings: np.ndarray) -> faiss.IndexFlatL2:
        index = faiss.IndexFlatL2(embeddings.shape[1])
        index.add(embeddings)
        return index

    def __call__(self, query: str, top_n: int = DEFAULT_TABLE_LIST_TOP_N) -> List[Dict]:
        query_embedding = get_embeddings([query])[0]
        distances, indices = self.index.search(np.array([query_embedding]), top_n)
        results = self._tables_with_embeddings_df.iloc[indices[0]].copy()
        results["score"] = distances[0]
        return results.to_dict(orient="records")


if __name__ == "__main__":
    searcher = CBSTableSearcher(CBSTableEmbedder())
    search_query = "hoeveel kippen zijn er in nederland?"
    top_n_results = 5
    search_results = searcher(search_query, top_n=top_n_results)
    print(f"Top {top_n_results} results for query '{search_query}':")
    print({r["Title"]: r["score"] for r in search_results})
